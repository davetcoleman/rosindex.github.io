<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>ROS Index</title>
    <meta name="description" content="A community-maintained index of known ROS packages.
">

    <link rel="canonical" href="http://rosindex.github.io/p/jsk_pcl_ros/rosdistro/">
    <link rel="stylesheet" type="text/css" href="/bootstrap/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/main.css">

    <script type="text/javascript" src="/js/jquery.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js" type="text/javascript"></script>
    <script src="/js/jquery-cookie-1.4.1/jquery.cookie.js" type="text/javascript"></script>

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">ROS Index</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <!--<a class="page-link" href="/p/jsk_pcl_ros/rosdistro/index.html"></a>-->
        <a class="page-link" href="/packages">Packages</a>
        <a class="page-link" href="/repos">Repositories</a>
        <a class="page-link" href="/search">Search</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="container-fluid" style="margin:20px">
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="/">Home</a></li>
      <li><a href="/packages">Packages</a></li>
      <li><a href="/packages/jsk_pcl_ros">jsk_pcl_ros</a></li>
      <li class="active">rosdistro</li>
    </ol>
  </div>
  <div class="row">
    <div class="well well-sm">
  <table class="table-condensed">
    <tbody>
      <tr>
        <!--<td><span class="pull-right">description</span></td>-->
        <td>
          <h4>jsk_recognition <small></small></h4>
          
        </td>
      </tr>
      
        <tr>
          <td>
<div id="repo-switch" class="btn-group btn-group-justified" role="group">
  <div class="btn-group" role="group">
    <div class="dropdown">
      <! -- TODO: add disabled when only 1 version is known -->
      <button class="btn btn-xs btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown">
        <span class="pull-left">
          <span class="glyphicon glyphicon-star"></span>
          rosdistro ( https://github.com/jsk-ros-pkg/jsk_recognition.git )
        </span>
        <span class="pull-right"><span class="caret"></span></span>
      </button>
      <ul class="dropdown-menu" role="menu">
        
          <li role="presentation">
          <a id="rosdistro" role="menuitem" tabindex="-1" href="/p/jsk_pcl_ros/rosdistro" data="rosdistro">
              <span class="glyphicon glyphicon-star"></span>
              rosdistro ( https://github.com/jsk-ros-pkg/jsk_recognition.git )
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</div>
</td>
        </tr>
      
      
        <tr>
          <td>
            

<div id="distro-switch" class="btn-group btn-group-justified" data-toggle="buttons">
  
  <label id="indigo-option" class="distro-button btn btn-xs btn-default" href="#indigo" data="indigo">
      <input type="radio" name="options" id="indigo-radio" autocomplete="off"> indigo
    </label>
  
  <label id="hydro-option" class="distro-button btn btn-xs btn-default" href="#hydro" data="hydro">
      <input type="radio" name="options" id="hydro-radio" autocomplete="off"> hydro
    </label>
  
  <label id="groovy-option" class="distro-button btn btn-xs btn-primary" href="#groovy" data="groovy">
      <input type="radio" name="options" id="groovy-radio" autocomplete="off"> groovy
    </label>
  

  <!-- Older distros -->
  <div class="btn-group dropdown">
    <label type="button" class="btn btn-xs dropdown-toggle btn-default" data-toggle="dropdown" id="older-distro-button">
    <input type="radio" name="options" autocomplete="off">
    <span id="older-label">Older</span>
    <span class="caret"></span>
  </label>
  <ul class="dropdown-menu" role="menu">
    
      <li data="fuerte" id="fuerte-option" class="disabled older-distro-option"  href="#fuerte">
      <a href="#fuerte" data="fuerte" id="fuerte-button">fuerte</a>
      </li>
    
      <li data="electric" id="electric-option" class="disabled older-distro-option"  href="#electric">
      <a href="#electric" data="electric" id="electric-button">electric</a>
      </li>
    
      <li data="diamondback" id="diamondback-option" class="disabled older-distro-option"  href="#diamondback">
      <a href="#diamondback" data="diamondback" id="diamondback-button">diamondback</a>
      </li>
    
      <li data="c-turtle" id="c-turtle-option" class="disabled older-distro-option"  href="#c-turtle">
      <a href="#c-turtle" data="c-turtle" id="c-turtle-button">c-turtle</a>
      </li>
    
  </ul>
</div>
</div>

          </td>
        </tr>
      
    </tbody>
  </table>
</div>

  </div>
  <div class="row">
    
      <div class="distro distro-indigo">
        
        <em>No branch for distro <strong>indigo</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
      <div class="distro distro-hydro">
        
        <em>No branch for distro <strong>hydro</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
      <div class="distro distro-groovy">
        
          
          <div class="panel panel-default">
            <div class="panel-heading">README</div>
            <div class="readme-" style="margin: 20px">
              <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><div class="rendered-markdown">
<h1>jsk_pcl_ros</h1>

<h2>Introduction</h2>

<p>jsk_pcl_ros is a package to provide some programs using <a href="http://pointclouds.org">pcl</a>.</p>

<p>This package provides some programs as nodelet.</p>

<h2>types</h2>

<p>jsk_pcl_ros provides several message types.</p>

<h3>ClusterPointIndices.msg</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
pcl_msgs/PointIndices[] cluster_indices
</code></pre></div>
<p>ClusterPointIndices is used to represent segmentation result.
Simply put, ClusterPointIndices is a list of PointIndices.</p>

<h3>ModelCoefficientsArray</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
pcl_msgs/ModelCoefficients[] coefficients
</code></pre></div>
<p>ModelCoefficientsArray is used to represent coefficients of model
for each segmented clusters.
Simply put, ModelCoefficientsArray is a list of ModelCoefficients.</p>

<h3>PolygonArray</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
geometry_msgs/PolygonStamped[] polygons
</code></pre></div>
<p>PolygonArray is a list of PolygonStamped.</p>

<p>You can use <a href="https://github.com/jsk-ros-pkg/jsk_visualization">jsk_rviz_plugins</a> to visualize PolygonArray in rviz.</p>

<h3>BoundingBox</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
geometry_msgs/Pose pose
geometry_msgs/Vector3 dimensions #x, y and z
</code></pre></div>
<p>BoundingBox represent a oriented bounding box. <code>dimensions</code> mean the
size of bounding box.</p>

<h3>BoundingBoxArray</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
BoundingBox[] boxes
</code></pre></div>
<p>BoundingBoxArray is a list of BoundingBox.
You can use <a href="https://github.com/jsk-ros-pkg/jsk_visualization">jsk_rviz_plugins</a> to visualize BoungingBoxArray in rviz.</p>

<h3>TimeRange</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">Header header
time start
time end
</code></pre></div>
<p>Represent range of time.</p>

<h2>nodelets</h2>

<h3>jsk_pcl/AttentionClipper</h3>

<h4>What Is This</h4>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/attention_clipper.png" alt=""></p>

<p>It retrives <code>sensor_msgs/CameraInfo</code> and publish <code>sensor_msgs/CameraInfo</code> with ROI filled.</p>

<p>You can specify the pose and size of the interest bounding box and jsk_pcl/AttentionClipper returns ROI
to see the object.</p>

<h4>Subscribing Topic</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/CameraInfo</code>)</li>
</ul>
<p>Original camera info.
* <code>~pose</code> (<code>geometry_msgs/PoseStamped</code>)</p>

<p>Specify the pose of the bounding box. timestamp will be ignored and camera info's timestamp will be used.</p>

<h4>Publishing Topic</h4>

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/CameraInfo</code>)</li>
</ul>
<p>This camera info is same with <code>~input</code> except for roi field.</p>

<h4>Parameter</h4>

<ul>
<li>
<code>~dimension_x</code> (Double, default: <code>0.1</code>)</li>
<li>
<code>~dimension_y</code> (Double, default: <code>0.1</code>)</li>
<li>
<code>~dimension_z</code> (Double, default: <code>0.1</code>)</li>
</ul>
<p>Size of bounding box</p>

<h3>jsk_pcl/ROIClipper</h3>

<h4>What Is This</h4>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/attention_clipper.png" alt=""></p>

<p>It retrives <code>sensor_msgs/Image</code> and <code>sensor_msgs/CameraInfo</code> and publish <code>sensor_msgs/Image</code> of ROI.
It is similar to <code>image_proc/crop_decimate</code> but you can use <code>CameraInfo/roi</code> field to specify ROI.</p>

<p>We expect to use jsk_pcl/ROIClipper with jsk_pcl/AttentionClipper to get ROI image.</p>

<h4>Subscribing Topic</h4>

<ul>
<li>
<code>~input/image</code> (<code>sensor_msgs/Image</code>)</li>
</ul>
<p>Input image.
* <code>~input/camera_info</code> (<code>sensor_msgs/CameraInfo</code>)</p>

<p>Camera parameter and ROI field should be filled.</p>

<p>These two topic should be synchronized.</p>

<h4>Publishing Topic</h4>

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/Image</code>)</li>
</ul>
<p>Image of ROI.</p>

<h3>jsk_pcl/NormalDirectionFilter</h3>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/normal_direction_filter.png" alt="NormalDirectionFilter"></p>

<p>jsk_pcl/NormalDirectionFilter filters pointcloud based on the direction of the normal.
It can filters pointcloud based on <strong>static</strong> direction and direction based on imu linear_acceleration.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>)</li>
</ul>
<p>input normal pointcloud.
* <code>~input_imu</code> (<code>sensor_msgs/Imu</code>)</p>

<p>imu message, which is enabled if <code>~use_imu</code> parameter is true</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output</code> (<code>pcl_msgs/PointIndices</code>)</li>
</ul>
<p>result of filtering as indices. You can use <code>pcl/ExtractIndices</code> to get pointcloud of the indices.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~use_imu</code> (Boolean, default: <code>False</code>):</li>
</ul>
<p>Enable <code>~input_imu</code> topic and set target direction based on imu linear acceleration.
* <code>~eps_angle</code> (Double, default: <code>0.2</code>):</p>

<p>Eps angle difference to regard the normal as required direction.
* <code>~angle_offset</code> (Double, default: <code>0.0</code>):</p>

<p>Offset parameter to the direction.
* <code>~direction</code> (Double Array, required):</p>

<p>if <code>~use_imu</code> is false, the direction should be specified with this parmaeter.</p>

<h3>jsk_pcl/MultiPlaneExtraction</h3>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/multi_plane_extraction.png" alt="MultiPlaneExtraction"></p>

<p>Extract the points above the planes between <code>~min_height</code> and <code>~max_height</code>.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input pointcloud.
* <code>~indices</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>)
* <code>~input_polygons</code> (<code>jsk_pcl_ros/PolygonArray</code>)
* <code>~input_coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>):</p>

<p>The input planes.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Pointcloud above the planes between <code>~min_height</code> and <code>~max_height</code>.
* <code>~output_nonplane_cloud</code> (<code>sensor_msgs/PointCloud2</code>):</p>

<p>Pointcloud above the planes is not between <code>~min_height</code> and <code>~max_height</code>.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~min_height</code> (Double, default: <code>0.0</code>)</li>
<li>
<code>~max_height</code>(Double, default: <code>0.5</code>)</li>
</ul>
<p>Minimum and maximum height of 3-D polygonal region to extract points.
* <code>~max_queue_size</code> (Integer, default: <code>100</code>)</p>

<p>Queue length for subscribing topics.</p>

<h3>jsk_pcl/RegionGrowingMultiplePlaneSegmentation</h3>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/region_growing_multiple_plane_segmentation.png" alt="jsk_pcl/RegionGrowingMultiplePlaneSegmentation">.</p>

<p>jsk_pcl/RegionGrowingMultiplePlaneSegmentation estimates multiple plenes from pointcloud.</p>

<p>It extracts planes based on <a href="http://en.wikipedia.org/wiki/Region_growing">region growing</a>
and evaluation function of connectivity if based on the following equation:
<img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/region_growing_multiple_plane_segmentation_eq.gif" alt=""></p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>input pointcloud.
* <code>~input_normal</code> (<code>sensor_msgs/PointCloud2</code>):</p>

<p>normal pointcloud of <code>~input</code></p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output/inliers</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):</li>
</ul>
<p>Set of indices of the polygons.
* <code>~output/coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>):</p>

<p>Array of coefficients of the polygons.
* <code>~output/polygons</code> (<code>jsk_pcl_ros/PolygonArray</code>):</p>

<p>Polygons</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~angular_threshold</code> (Double, default: <code>0.04</code>)</li>
</ul>
<p>Angular threshold to connect two points in one cluster. See
* <code>~distance_threshold</code> (Double, default: <code>0.1</code>)</p>

<p>Distance threshold to connect two points in one cluster.
* <code>~max_curvature</code> (Double, default: <code>0.1</code>)</p>

<p>Before extracting planes, filtering out the points which have higer curvature than this value.
* <code>~min_size</code> (Integer, default: <code>100</code>)</p>

<p>The minimum number of the points of each plane.
* <code>~cluster_tolerance</code> (Double, default: <code>0.1</code>)</p>

<p>The spatial tolerance for new cluster candidates.
* <code>~ransac_refine_outlier_distance_threshold</code> (Double, default: <code>0.1</code>)</p>

<p>Outlier threshold for plane estimation using RANSAC.
* <code>~ransac_refine_max_iterations</code> (Integer, default: <code>100</code>)</p>

<p>The maximum number of the iterations for plane estimation using RANSAC.</p>

<h3>jsk_pcl/ParticleFilterTracking</h3>

<h4>What Is This</h4>

<p>This nodelet will track the target pointcloud which you set in rviz.</p>

<h4>Sample</h4>

<p>run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros tracking_groovy.launch # (When use groovy)
roslaunch jsk_pcl_ros tracking_hydro.launch  #(When use hydro)
</code></pre></div>
<p>Push the "Select" button at the top bar , drag and surround the target poincloud which you want to track in the rectangle area.Then, finally, push the "SelectPointCloudPublishActoin" button at SelectPointCloudPublishAction Panel. The tracker will start tracking the target.</p>

<h3>jsk_pcl/ResizePointsPublisher</h3>

<h4>What is this</h4>

<p>ResizePointsPublisher resizes PointCloud generated from depth images. It keeps <em>organized</em> pointcloud. For example you can create QVGA pointcloud from VGA pointcloud of kinect like sensors.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input PointCloud. The input should be organized pointcloud.</p>

<h4>Publishing Topics.</h4>

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Output PointCloud. The output will be organized.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~step_x</code>, <code>~step_y</code> (Double, default: <code>2</code>):</li>
</ul>
<p>Bining step when resizing pointcloud.
* <code>~not_use_rgb</code> (Boolean, default: <code>false</code>):</p>

<p>If you want to resize pointcloud without RGB fields, you need to set this parameter to True.</p>

<h3>jsk_pcl/PointcloudScreenpoint</h3>

<h4>What is this</h4>

<p>This is a nodelet to convert (u, v) coordinate on a image to 3-D point.
It retrieves 3-D environment as pointcloud.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~points</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input pointcloud to represent 3-D environment it should be organized.
* <code>~point</code> (<code>geometry_msgs/PointStamped</code>):</p>

<p>Input point to represent (u, v) image coordinate and this topic is enabled only if <code>~use_point</code> parameter is set <code>True</code>.
   Only x and y fileds are used and the header frame_id is ignored.
   If <code>~use_sync</code> parameter is set <code>True</code>, <code>~points</code> and <code>~point</code> are synchronized.</p>

<ul>
<li>
<code>~polygon</code> (<code>geometry_msgs/PolygonStamped</code>):</li>
</ul>
<p>Input rectangular region on image local coordinates and this topic is enabled only if <code>~use_rect</code> parameter is set <code>True</code>.
   Only x and y fields are used and the header frame_id is ignored.
   And the region should be rectangular.
   If <code>~use_sync</code> parameter is set <code>True</code>,</p>

<ul>
<li>
<code>~point_array</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input points to represent series of (u, v) image coordinate and this
   topic is enabled only if <code>~use_point_array</code> parameter is set <code>True</code>.
   Only x and y fields are used and the header frame_id is ignored.
   If <code>~use_sync</code> parameter is set <code>True</code>, <code>~point_array</code> and <code>~point</code> are
   synchronized.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output_point</code> (<code>geometry_msgs/PointStamped</code>):</li>
</ul>
<p>The topic to be used to publish one point as a result of screenpoint.
* <code>~output</code> (<code>sensor_msgs/PointCloud</code>):</p>

<p>The topic to be used to publish series of points as a result of screenpoint.</p>

<h4>Advertising Servicies</h4>

<ul>
<li>
<code>~screen_to_point</code> (<code>jsk_pcl_ros::TransformScreenpoint</code>)</li>
</ul>
<p>ROS Service interface to convert (u, v) image coordinate into 3-D point.</p>

<p>The definition of <code>jsk_pcl_ros::TransformScreenpoint</code> is:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># screen point
float32 x
float32 y
---
# position in actual world
std_msgs/Header header
geometry_msgs/Point point
geometry_msgs/Vector3 vector
</code></pre></div>
<p>With int this service, the latest pointcloud acquired by <code>~points</code> is used to convert (u, v) into 3-D point.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~use_sync</code> (Boolean, default: <code>False</code>):</li>
</ul>
<p>If this parameter is set to <code>True</code>, the timestamps of 3-D pointcloud and the target point/rectangle/point array are synchronized.
* <code>~queue_size</code> (Integer, default: <code>1</code>):</p>

<p>Queue length of subscribing topics.
* <code>~crop_size</code> (Integer, default: <code>10</code>):</p>

<p>The size of approximate region if <code>~points</code> pointcloud has nan holes.
* <code>~use_rect</code> (Boolean, default: <code>False</code>):</p>

<p>Enable <code>~polygon</code> topic.
* <code>~use_point</code> (Boolean, default: <code>False</code>):</p>

<p>Enable <code>~point</code> topic.
* <code>~use_point_array</code> (Boolean, default: <code>False</code>):</p>

<p>Enable <code>~point_array</code> topic.
* <code>~publish_points</code> (Boolean, default: <code>False</code>):</p>

<p>Publish result of screenpoint to <code>~output</code> topic.
* <code>~publish_point</code> (Boolean, default: <code>False</code>):</p>

<p>Publish result of screenpoint to <code>~output_point</code> topic.</p>

<h3>jsk_pcl/TiltLaserListener</h3>

<h4>What is this</h4>

<p>Listen to the joint_states of tilt/spindle laser and publish time range to scane full 3-D space.
You can choose several types of tilt/spindle lasers such as tilt-laser of PR2, infinite spindle laser of multisense.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code>(<code>sensor_msgs/JointState</code>):</li>
</ul>
<p>Joint angles of laser actuator.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output</code> (<code>jsk_pcl_ros/TimeRange</code>):</li>
</ul>
<p>Time range to scan 3-D space.
* <code>~output_cloud</code> (<code>sensor_msgs/PointCloud2</code>):</p>

<p>Assembled pointcloud according to time range
   of <code>~output</code>. this require <code>~assemble_scans2</code>
   service of <a href="http://wiki.ros.org/laser_assembler">laser_assembler</a>.</p>

<h4>Using Services</h4>

<ul>
<li>
<code>~assemble_scans2</code> (<code>laser_assembler/AssembleScans2</code>):</li>
</ul>
<p>A service to build 3-D pointcloud from scan pointcloud.
   It should be remapped to <code>assemble_scans2</code> service of
   <a href="http://wiki.ros.org/laser_assembler">laser_assembler</a>.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~use_laser_assembler</code> (Boolean, default: <code>False</code>):</li>
</ul>
<p>Enable <code>~output_cloud</code> and <code>~assemble_scans2</code>.
* <code>~joint_name</code> (String, <strong>required</strong>):</p>

<p>Joint name of actuator to rotate laser.
* <code>~laser_type</code> (String, default: <code>tilt_half_down</code>):</p>

<p>type of rotating laser. You can choose one of the types:
   1. <code>tilt</code>: A mode for tilting laser. In this mode, TiltLaserListener assumes the motor to be moved from minimum
   joint angle to maximum joint angle over again. TiltLaserListener publishes the minimum and latest time range to
   move tilting laser from minimum joint angle to maximim joint angle.
   2. <code>tilt_half_down</code>:
   In this mode, TiltLaserListener publishes time range from maximum joint angle to minimum joint angle.
   3. <code>tilt_half_up</code>:
   In this mode, TiltLaserListener publishes time range from minimum joint angle to maximum joint angle like <code>tilt_half_down</code>.
   4. <code>infinite_spindle</code>: Infinite spindle laser. TiltLaserListener publishes time range to rotate laser 360 degrees.
   5. <code>infinite_spindle_half</code>: Infinite spindle laser, but most of laser has over 180 degrees range of field.
   Therefore we don't need to rotate laser 360 degrees to scan 3-D space, just 180 degree rotation is required.
   In this mode, TiltLaserListener publishes time range a time range of 180 degree rotation.</p>

<h3>jsk_pcl/DepthImageCreator</h3>

<h4>What is this</h4>

<p>Create <em>organized</em> pointcloud from non-organized pointcloud.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>The input pointcloud to be reconstructed as organized pointcloud.
* <code>~info</code> (<code>sensor_msgs/CameraInfo</code>):</p>

<p>Put a simulated camera according to <code>~info</code> and generate organized pointcloud.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/Image</code>):</li>
</ul>
<p>Publish organized pointcloud as depth image.
* <code>~output_cloud</code> (<code>sensor_msgs/PointCloud2</code>)</p>

<p>organized pointcloud.
* <code>~output_disp</code> (<code>sensor_msgs/DisparityImage</code>)</p>

<p>Publish organized pointcloud as disparity image.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~scale_depth</code> (Double, default: <code>1.0</code>)</li>
</ul>
<p>scale depth value.
* <code>~use_fixed_transform</code> (Boolean, default: <code>False</code>):
* <code>~translation</code> (Array of double, default: <code>[0, 0, 0]</code>)
* <code>~rotation</code> (Array of double, default: <code>[0, 0, 0, 1]</code>)</p>

<p>If <code>~use_fixed_transform</code> is set to <code>True</code>,
   transformation between <code>~input</code> and <code>~info</code> is not resolved via tf
   but fixed transformation is used according to <code>~rotation</code> and <code>translation</code>.
* <code>~use_asynchronous</code> (Boolean, default: <code>False</code>)</p>

<p>Do not synchronize <code>~input</code> and <code>~info</code> if this parameter is set to <code>True</code>.
* <code>~use_approximate</code> (Boolean, default: <code>False</code>)</p>

<p>Synchronize <code>~input</code> and <code>~info</code> approximately if this parameter is set to <code>True</code>.
* <code>~info_throttle</code> (Integer, default: <code>0</code>)</p>

<p>The number of <code>~info</code> messages to skip to generate depth image.
* <code>~max_queue_size</code> (integer, default: <code>3</code>):</p>

<p>Queue length of topics.</p>

<h3>jsk_pcl/EuclideanClustering</h3>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/euclidean_segmentation.png" alt=""></p>

<h4>What Is This</h4>

<p>Segment pointcloud based euclidean metrics, which is based on <code>pcl::EuclideanClusterExtraction</code>.
This nodelet has topic interface and service interface.</p>

<p>The result of clustering is published as <code>jsk_pcl_ros/ClusterPointIndices</code>.</p>

<p>If the number of the cluster is not changed across different frames, <code>EuclideanClustering</code>
tries to track the segment.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>input pointcloud.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>~output</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):</li>
</ul>
<p>Result of clustering.
* <code>~cluster_num</code> (<code>jsk_pcl_ros/Int32Stamped</code>):</p>

<p>The number of clusters.</p>

<h4>Advertising Services</h4>

<ul>
<li>
<code>~euclidean_clustering</code> (<code>jsk_pcl_ros/EuclideanSegment</code>):</li>
</ul>
<p>Service interface to segment clusters.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">sensor_msgs/PointCloud2 input
float32 tolerance
---
sensor_msgs/PointCloud2[] output
</code></pre></div>
<h4>Parameters</h4>

<ul>
<li>
<code>~tolerance</code> (Double, default: <code>0.02</code>):</li>
</ul>
<p>Max distance for the points to be regarded as same cluster.
* <code>~label_tracking_tolerance</code> (Double, default: <code>0.2</code>)</p>

<p>Max distance to track the cluster between different frames.
* <code>~max_size</code> (Integer, default: <code>25000</code>)</p>

<p>The maximum number of the points of one cluster.
* <code>~min_size</code> (Integer, default: <code>20</code>)</p>

<p>The minimum number of the points of one cluster.</p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros euclidean_segmentation.launch
</code></pre></div>
<h3>jsk_pcl/ClusterPointIndicesDecomposer</h3>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/bounding_box.png" alt=""></p>

<h4>What is this</h4>

<p>Decompose <code>jsk_pcl_ros/ClusterPointIndices</code> into array of topics of <code>sensor_msgs/PointCloud</code> like <code>~output00</code>, <code>~output01</code> and so on.
It also publishes tf of centroids of each cluster and oriented bounding box of them. The direction of the bounding box are aligned on to the nearest planes if available.</p>

<h4>Subscribing topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input pointcloud.
* <code>~target</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):</p>

<p>Input set of indices to represent clusters.
* <code>~align_planes</code> (<code>jsk_pcl_ros/PolygonArray</code>):
* <code>~align_planes_coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>):</p>

<p>The planes for bounding box to be aligned on.</p>

<h4>Publishing topics</h4>

<ul>
<li>
<code>~output%02d</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Series of topics for each pointcloud cluster.
* <code>~debug_output</code> (<code>sensor_msgs/PointCloud2</code>):</p>

<p>Concatenate all the clusters into one pointcloud and colorize each cluster to see the result of segmentation.
* <code>~boxes</code> (<code>jsk_pcl_ros/BoundingBoxArray</code>):</p>

<p>Array of oriented bounding box for each segmented cluster.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~publish_tf</code> (Boolean, default: <code>True</code>):</li>
</ul>
<p>Toggle tf publishing.
* <code>~publish_clouds</code> (Boolean, default: <code>True</code>):</p>

<p>Toggle <code>~output%02d</code> topics.
* <code>~align_boxes</code> (Boolean, default: <code>False</code>):</p>

<p>If this parameter is set to <code>True</code>, <code>~align_planes</code> and
   <code>~align_planes_coefficients</code> are enabled.
* <code>~use_pca</code> (Boolean, default: <code>False</code>):</p>

<p>Run PCA algorithm on each cluster to estimate x and y direction.</p>

<h3>jsk_pcl/ClusterPointIndicesDecomposerZAxis</h3>

<h4>What Is This</h4>

<p>This nodelet is almost same to jsk_pcl/ClusterPointIndicesDecomposer, however it always sort clusters in z direction.</p>

<h3>jsk_pcl/CentroidPublisher</h3>

<h4>What Is This</h4>

<p>This nodelet will subscribe the sensor_msgs::PointCloud2, calculate its centroid  and boardcast the tf whose parent is cloud headers frame_id and whose child is the new centroid frame_id.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>input pointcloud.</p>

<h4>Publishing Topics</h4>

<ul>
<li>
<code>/tf</code>:</li>
</ul>
<p>Publish tf of the centroid of the input pointcloud.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~frame</code> (String, required):</li>
</ul>
<p>frame_id of centroid tf</p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros centroid_publisher.launch
</code></pre></div>
<h3>jsk_pcl/OrganizedMultiPlaneSegmentation</h3>

<h4>What Is This</h4>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/organized_multi_plane_segmentation.png" alt="images/organized_multi_plane_segmentation.png"></p>

<p>This nodelet segments multiple planes from <strong>organized</strong> pointcloud.
It estimates planes based on <a href="http://en.wikipedia.org/wiki/Connected-component_labeling">connected-component analysis</a>
using <code>pcl::OrganizedMultiPlaneSegmentation</code>.</p>

<p><img src="https://raw.githubusercontent.com//jsk-ros-pkg/jsk_recognition.git/#&lt;Rugged::Branch:0x00000006d4bce0&gt;/jsk_pcl_ros//images/graph/organized_multi_plane_segmentation_overview.png" alt="overview"> shows the overview of the pipeline.</p>

<ol>
<li>Estimate normal using integral image.</li>
<li>Conduct connected component analysis to estimate planar regions.</li>
<li>Connect neighbor planes if the normal directions and the borders of the planes are near enough.</li>
<li>Refine plane coefficients of connected planes based on RANSAC. If the areas of the planes after refinement are too small, they will be removed.</li>
</ol>
<p>These process is implemented in one nodelet in order not to convert pointcloud between
PCL and ROS.</p>

<h4>Subscribing Topics</h4>

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>):</li>
</ul>
<p>Input pointcloud. This should be <strong>organized</strong> pointcloud.</p>

<h4>Publishing topisc</h4>

<ul>
<li>
<code>~output</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):</li>
<li>
<code>~output_polygon</code> (<code>jsk_pcl_ros/PolygonArray</code>):</li>
<li>
<code>~output_coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>)</li>
</ul>
<p>The inliers, coefficients and convex polygons of the connected polygons.
* <code>~output_nonconnected</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):
* <code>~output_nonconnected_polygon</code> (<code>jsk_pcl_ros/PolygonArray</code>):
* <code>~output_nonconnected_coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>)</p>

<p>The inliers, coefficients and polygons of the polygons of connected components analysis.
* <code>~output_refined</code> (<code>jsk_pcl_ros/ClusterPointIndices</code>):
* <code>~output_refined_polygon</code> (<code>jsk_pcl_ros/PolygonArray</code>):
* <code>~output_refined_coefficients</code> (<code>jsk_pcl_ros/ModelCoefficientsArray</code>)</p>

<p>The inliers, coefficients and convex polygons of the refined polygons.
* <code>~output_normal</code> (<code>sensor_msgs/PointCloud2</code>):</p>

<p>The pointcloud of normal of <code>~input</code> pointcloud.</p>

<h4>Parameters</h4>

<ul>
<li>
<code>~estimate_normal</code> (Boolean, default: <code>True</code>):</li>
</ul>
<p>Estimate normal if it is set to <code>True</code>
* <code>~publish_normal</code> (Boolean, default: <code>False</code>):</p>

<p>Publish the result of normal to <code>~output_normal</code>
* <code>~max_depth_change_factor</code> (Double, default: <code>0.02</code>):</p>

<p>The depth change threshold for computing object borders in normal estimation.
* <code>~normal_smoothing_size</code> (Double, default: <code>20.0</code>):</p>

<p>the size of the area used to smooth normals
   (depth dependent if <code>~depth_dependent_smoothing</code> is true)
* <code>~depth_dependent_smoothing</code> (Boolean, default: <code>False</code>)</p>

<p>Smooth normal depending on depth
* <code>~estimation_method</code> (Integer, default: <code>1</code>)</p>

<p>Estimation method of normal. You can choose one of <code>AVERAGE_3D_GRADIENT(0)</code>, <code>COVARIANCE_MATRIX(1)</code> and <code>AVERAGE_DEPTH_CHANGE(2)</code>.
* <code>~border_policy_ignore</code> (Boolean, default: <code>True</code>)</p>

<p>Ignore border if this is <code>True</code>
* <code>~min_size</code> (Integer, default: <code>2000</code>)</p>

<p>Minimum number of the points on a planar region during connected component analysis.
   We recommend smaller size for this parameter in order to get stable result.
* <code>~angular_threshold</code> (Double, default: <code>0.05</code>)
* <code>~distance_threshold</code> (Double, default: <code>0.01</code>)</p>

<p>Distance and angular threshold in connected component analysis.
* <code>~max_curvature</code> (Double, default: <code>0.001</code>)</p>

<p>The maximum curvature allowed for a planar region
* <code>~connect_plane_angle_threshold</code> (Double, default: <code>0.2</code>)
* <code>~connect_distance_threshold</code> (Double, default: <code>0.01</code>)</p>

<p>These parameters affect near plane connection. OrganizedMultiPlaneSegmentation connects
   planes which have near normal direction and whose boundaries are near enough.
* <code>~ransac_refine_coefficients</code> (Boolean, default: <code>True</code>)</p>

<p>Conduct RANSAC refinment for each plane if it is true.
* <code>~ransac_refine_outlier_distance_threshold</code> (Double, default: <code>0.1</code>)</p>

<p>Outlier threshold of RANSAC refinment for each plane.
* <code>~min_refined_area_threshold</code> (Double, default: <code>0.04</code>)
* <code>~max_refined_area_threshold</code> (Double, default: <code>10000</code>)</p>

<p>Minimum and maximum area threshold for each convex polygon.</p>

<h3>jsk_pcl/VoxelGridDownsampleManager</h3>

<h3>jsk_pcl/VoxelGridDownsampleDecoder</h3>

<h3>jsk_pcl/Snapit</h3>

<h4>What Is This</h4>

<p>This nodelet will snap the plane to the real world pointcloud.
Move the interactive marker and the snapped plane will follow the movement.</p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros snapit_sample.launch
</code></pre></div>
<h3>jsk_pcl/KeypointsPublisher</h3>

<h4>What Is This</h4>

<p>This nodelet will calculate the NURF keypoints and publish.</p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros keypoints_publisher.launch
</code></pre></div>
<h3>jsk_pcl/HintedPlaneDetector</h3>

<h4>What Is This</h4>

<p>This nodelet will snap the plane to the real world pointcloud.
Move the interactive marker and the snapped plane will follow the movement.</p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros hinted_plane_detector_sample.launch
</code></pre></div>
<h3>jsk_pcl/OctreeChangeDetector</h3>

<h4>What Is This</h4>

<p>This nodelet will publish the difference of sequential pointcloud. You can get the newly generated pointclouds.</p>

<p>Difference with pcl_ros/SegmentDifference refer <a href="https://github.com/jsk-ros-pkg/jsk_recognition/pull/67">https://github.com/jsk-ros-pkg/jsk_recognition/pull/67</a></p>

<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros octree_change_detector.launch
</code></pre></div>
<h4>Speed</h4>

<h3>jsk_pcl/ROIClipper</h3>

<h4>What Is This</h4>

<h3>jsk_pcl/TfTransformCloud</h3>

<h4>What Is This</h4>

<p>This nodelet will republish the pointcloud which is transformed with the designated frame_id.</p>

<h4>Topics</h4>

<ul>
<li>Input

<ul>
<li>
<code>~input</code> (<code>sensor_msgs/PointCloud2</code>): input pointcloud</li>
</ul>
</li>
<li>Output

<ul>
<li>
<code>~output</code> (<code>sensor_msgs/PointCloud2</code>): output pointcloud.</li>
</ul>
</li>
</ul>
<h4>Parameters</h4>

<ul>
<li>
<code>~target_frame_id</code> (string): The frame_id to transform pointcloud.</li>
</ul>
<h4>Sample</h4>

<p>Plug the depth sensor which can be launched by openni.launch and run the below command.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">roslaunch jsk_pcl_ros tf_transform_cloud.launch
</code></pre></div>
<h2>To Test Some Samples</h2>

<p>Please be careful about the nodelet manager name when execute some sample launches.</p>

<p>Because the nodelet manager name is different between groovy version and hydro version in openni.launch,
you have to replace the nodelet manager name when use in groovy as below.</p>

<p>From</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/camera_nodelet_manager
</code></pre></div>
<p>To</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">/camera/camera_nodelet_manager
</code></pre></div>
</div></body></html>

            </div>
          </div>
        
      </div>
    
      <div class="distro distro-fuerte">
        
        <em>No branch for distro <strong>fuerte</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
      <div class="distro distro-electric">
        
        <em>No branch for distro <strong>electric</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
      <div class="distro distro-diamondback">
        
        <em>No branch for distro <strong>diamondback</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
      <div class="distro distro-c-turtle">
        
        <em>No branch for distro <strong>c-turtle</strong>. Known supported distros are highlighted in the buttons above.</em>
        
      </div>
    
  </div>
</div>

<script src="/js/distro_switch.js"></script>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>ROS Index</li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/rosindex">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">rosindex</span>
            </a>
          </li>
          

        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">A community-maintained index of known ROS packages.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
